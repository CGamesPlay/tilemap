{"version":3,"file":"pixi-tilemap.umd.min.js","sources":["../src/CanvasTileRenderer.ts","../node_modules/tslib/tslib.es6.js","../src/Constant.ts","../src/RectTileLayer.ts","../src/CompositeRectTileLayer.ts","../src/GraphicsLayer.ts","../src/MultiTextureResource.ts","../src/shaderGenerator.ts","../src/RectTileShader.ts","../src/TileRenderer.ts","../src/exporter.ts","../src/ZLayer.ts","../src/index.ts"],"sourcesContent":["/// <reference path=\"types.d.ts\" />\n\nimport { Renderer } from '@pixi/core';\n\nexport class CanvasTileRenderer {\n    renderer: Renderer;\n    tileAnim = [0, 0];\n    dontUseTransform = false;\n\n    constructor(renderer: Renderer) {\n        this.renderer = renderer;\n        this.tileAnim = [0, 0];\n    }\n}\n\nconst cr = (PIXI as any).CanvasRenderer;\n\nif (cr) {\n    cr.registerPlugin('tilemap', CanvasTileRenderer);\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export const Constant = {\n    maxTextures: 16,\n    bufferSize: 2048,\n    boundSize: 1024,\n    boundCountPerBuffer: 1,\n    use32bitIndex: false,\n    SCALE_MODE: PIXI.SCALE_MODES.LINEAR,\n    DO_CLEAR: true\n};","/// <reference path=\"types.d.ts\" />\n\nimport { Container } from '@pixi/display';\nimport { Constant } from './Constant';\nimport { DRAW_MODES } from '@pixi/constants';\nimport { Texture, Renderer } from '@pixi/core';\nimport { TileRenderer } from './TileRenderer';\nimport { Matrix, groupD8 } from '@pixi/math';\n\nimport type { RectTileGeom } from './RectTileShader';\n\nexport const POINT_STRUCT_SIZE = 12;\n\nexport class RectTileLayer extends Container {\n    constructor(zIndex: number, texture: Texture | Array<Texture>) {\n        super();\n        this.initialize(zIndex, texture);\n    }\n\n    zIndex = 0;\n    modificationMarker = 0;\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    _globalMat: Matrix = null;\n\n    pointsBuf: Array<number> = [];\n    hasAnim = false;\n    textures: Array<Texture>;\n\n    offsetX = 0;\n    offsetY = 0;\n    compositeParent = false;\n\n    initialize(zIndex: number, textures: Texture | Array<Texture>) {\n        if (!textures) {\n            textures = [];\n        } else if (!(textures instanceof Array) && (textures as Texture).baseTexture) {\n            textures = [textures as Texture];\n        }\n        this.textures = textures as Array<Texture>;\n        this.zIndex = zIndex;\n        // this.visible = false;\n    }\n\n    clear() {\n        this.pointsBuf.length = 0;\n        this.modificationMarker = 0;\n        this.hasAnim = false;\n    }\n\n    addFrame(texture_: Texture | String | number, x: number, y: number, animX: number, animY: number) {\n        let texture: Texture;\n        let textureIndex = 0;\n\n        if (typeof texture_ === \"number\") {\n            textureIndex = texture_;\n            texture = this.textures[textureIndex];\n        } else {\n            if (typeof texture_ === \"string\") {\n                texture = Texture.from(texture_);\n            } else {\n                texture = texture_ as Texture;\n            }\n\n            let found = false;\n            let textureList = this.textures;\n            for (let i = 0; i < textureList.length; i++) {\n                if (textureList[i].baseTexture === texture.baseTexture) {\n                    textureIndex = i;\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                // textureIndex = this.textures.length;\n                // this.textures.push(texture);\n                return false;\n            }\n        }\n\n        this.addRect(textureIndex, texture.frame.x, texture.frame.y, x, y, texture.orig.width, texture.orig.height, animX, animY, texture.rotate);\n        return true;\n    }\n\n    addRect(textureIndex: number, u: number, v: number, x: number, y: number, tileWidth: number, tileHeight: number,\n            animX: number = 0, animY: number = 0, rotate: number = 0, animCountX: number = 1024, animCountY: number = 1024): this {\n        let pb = this.pointsBuf;\n        this.hasAnim = this.hasAnim || animX > 0 || animY > 0;\n        pb.push(u);\n        pb.push(v);\n        pb.push(x);\n        pb.push(y);\n        pb.push(tileWidth);\n        pb.push(tileHeight);\n        pb.push(rotate);\n        pb.push(animX | 0);\n        pb.push(animY | 0);\n        pb.push(textureIndex);\n        pb.push(animCountX);\n        pb.push(animCountY);\n\n        return this;\n    }\n\n    tileRotate(rotate: number) {\n        const pb = this.pointsBuf;\n        pb[pb.length - 3] = rotate;\n    }\n\n    tileAnimX(offset: number, count: number) {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - 5] = offset;\n        pb[pb.length - 2] = count;\n    }\n\n    tileAnimY(offset: number, count: number) {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - 4] = offset;\n        pb[pb.length - 1] = count;\n    }\n\n    renderCanvas(renderer: any) {\n        let plugin = renderer.plugins.tilemap;\n        if (!plugin.dontUseTransform) {\n            let wt = this.worldTransform;\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                wt.tx * renderer.resolution,\n                wt.ty * renderer.resolution\n            );\n        }\n        this.renderCanvasCore(renderer);\n    }\n\n    renderCanvasCore(renderer: any) {\n        if (this.textures.length === 0) return;\n        let points = this.pointsBuf;\n        renderer.context.fillStyle = '#000000';\n        for (let i = 0, n = points.length; i < n; i += POINT_STRUCT_SIZE) {\n            let x1 = points[i], y1 = points[i + 1];\n            let x2 = points[i + 2], y2 = points[i + 3];\n            let w = points[i + 4];\n            let h = points[i + 5];\n            var rotate = points[i + 6];\n            x1 += points[i + 7] * renderer.plugins.tilemap.tileAnim[0];\n            y1 += points[i + 8] * renderer.plugins.tilemap.tileAnim[1];\n            let textureIndex = points[i + 9];\n            // canvas does not work with rotate yet\n            if (textureIndex >= 0) {\n                renderer.context.drawImage((this.textures[textureIndex].baseTexture as any).getDrawableSource(), x1, y1, w, h, x2, y2, w, h);\n            } else {\n                renderer.context.globalAlpha = 0.5;\n                renderer.context.fillRect(x2, y2, w, h);\n                renderer.context.globalAlpha = 1;\n            }\n        }\n    }\n\n    vbId = 0;\n    vb: RectTileGeom = null;\n    vbBuffer: ArrayBuffer = null;\n    vbArray: Float32Array = null;\n    vbInts: Uint32Array = null;\n\n    destroyVb() {\n        if (this.vb) {\n            this.vb.destroy();\n            this.vb = null;\n        }\n    }\n\n    render(renderer: Renderer) {\n        let plugin = (renderer.plugins as any)['tilemap'];\n        let shader = plugin.getShader();\n        renderer.batch.setObjectRenderer(plugin);\n        this._globalMat = shader.uniforms.projTransMatrix;\n        renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);\n        shader.uniforms.shadowColor = this.shadowColor;\n        shader.uniforms.animationFrame = plugin.tileAnim;\n        this.renderWebGLCore(renderer, plugin);\n    }\n\n    renderWebGLCore(renderer: Renderer, plugin: TileRenderer) {\n        let points = this.pointsBuf;\n        if (points.length === 0) return;\n        let rectsCount = points.length / POINT_STRUCT_SIZE;\n\n        let shader = plugin.getShader();\n        let textures = this.textures;\n        if (textures.length === 0) return;\n\n        plugin.bindTextures(renderer, shader, textures);\n        renderer.shader.bind(shader, false);\n\n        //lost context! recover!\n        let vb = this.vb;\n        if (!vb) {\n            vb = plugin.createVb();\n            this.vb = vb;\n            this.vbId = (vb as any).id;\n            this.vbBuffer = null;\n            this.modificationMarker = 0;\n        }\n\n        plugin.checkIndexBuffer(rectsCount, vb);\n        const boundCountPerBuffer = Constant.boundCountPerBuffer;\n\n        let vertexBuf = vb.getBuffer('aVertexPosition');\n        //if layer was changed, re-upload vertices\n        let vertices = rectsCount * vb.vertPerQuad;\n        if (vertices === 0) return;\n        if (this.modificationMarker !== vertices) {\n            this.modificationMarker = vertices;\n            let vs = vb.stride * vertices;\n            if (!this.vbBuffer || this.vbBuffer.byteLength < vs) {\n                //!@#$ happens, need resize\n                let bk = vb.stride;\n                while (bk < vs) {\n                    bk *= 2;\n                }\n                this.vbBuffer = new ArrayBuffer(bk);\n                this.vbArray = new Float32Array(this.vbBuffer);\n                this.vbInts = new Uint32Array(this.vbBuffer);\n                vertexBuf.update(this.vbBuffer);\n            }\n\n            let arr = this.vbArray, ints = this.vbInts;\n            //upload vertices!\n            let sz = 0;\n            //let tint = 0xffffffff;\n            let textureId: number = 0;\n            let shiftU: number = this.offsetX;\n            let shiftV: number = this.offsetY;\n\n            //let tint = 0xffffffff;\n            let tint = -1;\n            for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE) {\n                let eps = 0.5;\n                if (this.compositeParent) {\n                    if (boundCountPerBuffer > 1) {\n                        //TODO: what if its more than 4?\n                        textureId = (points[i + 9] >> 2);\n                        shiftU = this.offsetX * (points[i + 9] & 1);\n                        shiftV = this.offsetY * ((points[i + 9] >> 1) & 1);\n                    } else {\n                        textureId = points[i + 9];\n                        shiftU = 0;\n                        shiftV = 0;\n                    }\n                }\n                let x = points[i + 2], y = points[i + 3];\n                let w = points[i + 4], h = points[i + 5];\n                let u = points[i] + shiftU, v = points[i + 1] + shiftV;\n                let rotate = points[i + 6];\n\n                const animX = points[i + 7], animY = points[i + 8];\n                const animWidth = points[i + 10] || 1024, animHeight = points[i + 11] || 1024;\n                const animXEncoded = animX + (animWidth * 2048);\n                const animYEncoded = animY + (animHeight * 2048);\n\n                let u0: number, v0: number, u1: number, v1: number, u2: number, v2: number, u3: number, v3: number;\n                if (rotate === 0) {\n                    u0 = u;\n                    v0 = v;\n                    u1 = u + w;\n                    v1 = v;\n                    u2 = u + w;\n                    v2 = v + h;\n                    u3 = u;\n                    v3 = v + h;\n                } else {\n                    let w2 = w / 2;\n                    let h2 = h / 2;\n                    if (rotate % 4 !== 0) {\n                        w2 = h / 2;\n                        h2 = w / 2;\n                    }\n                    const cX = u + w2;\n                    const cY = v + h2;\n\n                    rotate = groupD8.add(rotate, groupD8.NW);\n                    u0 = cX + (w2 * groupD8.uX(rotate));\n                    v0 = cY + (h2 * groupD8.uY(rotate));\n\n                    rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n                    u1 = cX + (w2 * groupD8.uX(rotate));\n                    v1 = cY + (h2 * groupD8.uY(rotate));\n\n                    rotate = groupD8.add(rotate, 2);\n                    u2 = cX + (w2 * groupD8.uX(rotate));\n                    v2 = cY + (h2 * groupD8.uY(rotate));\n\n                    rotate = groupD8.add(rotate, 2);\n                    u3 = cX + (w2 * groupD8.uX(rotate));\n                    v3 = cY + (h2 * groupD8.uY(rotate));\n                }\n\n                arr[sz++] = x;\n                arr[sz++] = y;\n                arr[sz++] = u0;\n                arr[sz++] = v0;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y;\n                arr[sz++] = u1;\n                arr[sz++] = v1;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y + h;\n                arr[sz++] = u2;\n                arr[sz++] = v2;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n                arr[sz++] = x;\n                arr[sz++] = y + h;\n                arr[sz++] = u3;\n                arr[sz++] = v3;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n            }\n\n            vertexBuf.update(arr);\n        }\n\n        (renderer.geometry as any).bind(vb, shader);\n        renderer.geometry.draw(DRAW_MODES.TRIANGLES, rectsCount * 6, 0);\n    }\n\n    isModified(anim: boolean) {\n        if (this.modificationMarker !== this.pointsBuf.length ||\n            anim && this.hasAnim) {\n            return true;\n        }\n        return false;\n    }\n\n    clearModify() {\n        this.modificationMarker = this.pointsBuf.length;\n    }\n\n    destroy(options?: any) {\n        super.destroy(options);\n        this.destroyVb();\n    }\n}\n","/// <reference path=\"types.d.ts\" />\n\nimport { Container } from '@pixi/display';\nimport { Texture, Renderer } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\nimport { Constant } from './Constant';\nimport { RectTileLayer } from './RectTileLayer';\n\nexport class CompositeRectTileLayer extends Container {\n    constructor(zIndex?: number, bitmaps?: Array<Texture>, texPerChild?: number) {\n        super();\n        this.initialize.apply(this, arguments);\n    }\n\n    updateTransform() {\n        (this as any).displayObjectUpdateTransform();\n    }\n\n    z: number;\n    zIndex: number;\n    modificationMarker = 0;\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    _globalMat: Matrix = null;\n    _lastLayer: RectTileLayer = null;\n\n    texPerChild: number;\n\n    initialize(zIndex?: number, bitmaps?: Array<Texture>, texPerChild?: number) {\n        if (texPerChild as any === true) {\n            //old format, ignore it!\n            texPerChild = 0;\n        }\n        this.z = this.zIndex = zIndex;\n        this.texPerChild = texPerChild || Constant.boundCountPerBuffer * Constant.maxTextures;\n        if (bitmaps) {\n            this.setBitmaps(bitmaps);\n        }\n    }\n\n    setBitmaps(bitmaps: Array<Texture>) {\n        for (let i=0;i<bitmaps.length;i++) {\n            if (bitmaps[i] && !bitmaps[i].baseTexture) {\n                throw new Error(`pixi-tilemap cannot use destroyed textures. `+\n                    `Probably, you passed resources['myAtlas'].texture in pixi > 5.2.1, it does not exist there.`);\n            }\n        }\n        let texPerChild = this.texPerChild;\n        let len1 = this.children.length;\n        let len2 = Math.ceil(bitmaps.length / texPerChild);\n        let i: number;\n        for (i = 0; i < len1; i++) {\n            (this.children[i] as RectTileLayer).textures = bitmaps.slice(i * texPerChild, (i + 1) * texPerChild);\n        }\n        for (i = len1; i < len2; i++) {\n            let layer = new RectTileLayer(this.zIndex, bitmaps.slice(i * texPerChild, (i + 1) * texPerChild));\n            layer.compositeParent = true;\n            layer.offsetX = Constant.boundSize;\n            layer.offsetY = Constant.boundSize;\n            this.addChild(layer);\n        }\n    }\n\n    clear() {\n        for (let i = 0; i < this.children.length; i++) {\n            (this.children[i] as RectTileLayer).clear();\n        }\n        this.modificationMarker = 0;\n    }\n\n    addRect(textureIndex: number, u: number, v: number, x: number, y: number, tileWidth: number, tileHeight: number, animX?: number, animY?: number, rotate?: number, animWidth?: number, animHeight?: number): this {\n        const childIndex: number = textureIndex / this.texPerChild >> 0;\n        const textureId: number = textureIndex % this.texPerChild;\n\n        if (this.children[childIndex] && (this.children[childIndex] as RectTileLayer).textures) {\n            this._lastLayer = (this.children[childIndex] as RectTileLayer);\n            this._lastLayer.addRect(textureId, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight);\n        } else {\n            this._lastLayer = null;\n        }\n\n        return this;\n    }\n\n    tileRotate(rotate: number): this {\n        if (this._lastLayer)\n        {\n            this._lastLayer.tileRotate(rotate);\n        }\n        return this;\n    }\n\n    tileAnimX(offset: number, count: number): this {\n        if (this._lastLayer)\n        {\n            this._lastLayer.tileAnimX(offset, count);\n        }\n        return this;\n    }\n\n    tileAnimY(offset: number, count: number): this {\n        if (this._lastLayer)\n        {\n            this._lastLayer.tileAnimY(offset, count);\n        }\n        return this;\n    }\n\n    addFrame(texture_: Texture | String | number, x: number, y: number, animX?: number, animY?: number, animWidth?: number, animHeight?: number): this {\n        let texture: Texture;\n        let layer: RectTileLayer = null;\n        let ind: number = 0;\n        let children = this.children;\n\n        this._lastLayer = null;\n        if (typeof texture_ === \"number\") {\n            let childIndex = texture_ / this.texPerChild >> 0;\n            layer = children[childIndex] as RectTileLayer;\n\n            if (!layer) {\n                layer = children[0] as RectTileLayer;\n                if (!layer) {\n                    return this;\n                }\n                ind = 0;\n            } else {\n                ind = texture_ % this.texPerChild;\n            }\n\n            texture = layer.textures[ind];\n        } else {\n            if (typeof texture_ === \"string\") {\n                texture = Texture.from(texture_);\n            } else {\n                texture = texture_ as Texture;\n            }\n\n            for (let i = 0; i < children.length; i++) {\n                let child = children[i] as RectTileLayer;\n                let tex = child.textures;\n                for (let j = 0; j < tex.length; j++) {\n                    if (tex[j].baseTexture === texture.baseTexture) {\n                        layer = child;\n                        ind = j;\n                        break;\n                    }\n                }\n                if (layer) {\n                    break;\n                }\n            }\n\n            if (!layer) {\n                for (let i = 0; i < children.length; i++) {\n                    let child = children[i] as RectTileLayer;\n                    if (child.textures.length < this.texPerChild) {\n                        layer = child;\n                        ind = child.textures.length;\n                        child.textures.push(texture);\n                        break;\n                    }\n                }\n                if (!layer) {\n                    layer = new RectTileLayer(this.zIndex, texture);\n                    layer.compositeParent = true;\n                    layer.offsetX = Constant.boundSize;\n                    layer.offsetY = Constant.boundSize;\n                    children.push(layer);\n                    ind = 0;\n                }\n            }\n        }\n\n        this._lastLayer = layer;\n        layer.addRect(ind, texture.frame.x, texture.frame.y, x, y, texture.orig.width, texture.orig.height, animX, animY, texture.rotate, animWidth, animHeight);\n        return this;\n    }\n\n    renderCanvas(renderer: any) {\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n            return;\n        }\n        let plugin = renderer.plugins.tilemap;\n        if (!plugin.dontUseTransform) {\n            let wt = this.worldTransform;\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                wt.tx * renderer.resolution,\n                wt.ty * renderer.resolution\n            );\n        }\n        let layers = this.children;\n        for (let i = 0; i < layers.length; i++) {\n            (layers[i] as RectTileLayer).renderCanvasCore(renderer);\n        }\n    }\n\n    render(renderer: Renderer) {\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n            return;\n        }\n        let plugin = (renderer.plugins as any)['tilemap'];\n        let shader = plugin.getShader();\n        renderer.batch.setObjectRenderer(plugin);\n        //TODO: dont create new array, please\n        this._globalMat = shader.uniforms.projTransMatrix;\n        renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);\n        shader.uniforms.shadowColor = this.shadowColor;\n        shader.uniforms.animationFrame = plugin.tileAnim;\n        renderer.shader.bind(shader, false);\n        let layers = this.children;\n        for (let i = 0; i < layers.length; i++) {\n            (layers[i] as RectTileLayer).renderWebGLCore(renderer, plugin);\n        }\n    }\n\n    isModified(anim: boolean) {\n        let layers = this.children;\n        if (this.modificationMarker !== layers.length) {\n            return true;\n        }\n        for (let i = 0; i < layers.length; i++) {\n            if ((layers[i] as RectTileLayer).isModified(anim)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    clearModify() {\n        let layers = this.children;\n        this.modificationMarker = layers.length;\n        for (let i = 0; i < layers.length; i++) {\n            (layers[i] as RectTileLayer).clearModify();\n        }\n    }\n}","/// <reference path=\"types.d.ts\" />\n\nimport { Matrix } from '@pixi/math';\nimport { Graphics } from '@pixi/graphics';\n\nexport class GraphicsLayer extends Graphics {\n    constructor(zIndex: number) {\n        super();\n        this.zIndex = zIndex;\n    }\n\n    renderCanvas(renderer: any) {\n        let wt: Matrix = null;\n        if (renderer.plugins.tilemap.dontUseTransform) {\n            wt = this.transform.worldTransform;\n            this.transform.worldTransform = Matrix.IDENTITY;\n        }\n        renderer.plugins.graphics.render(this);\n        if (renderer.plugins.tilemap.dontUseTransform) {\n            this.transform.worldTransform = wt;\n        }\n        renderer.context.globalAlpha = 1.0;\n    }\n\n    // renderWebGL(renderer: PIXI.Renderer) {\n    //     if (!this._webGL[renderer.CONTEXT_UID])\n    //         this.dirty++;\n    //     super.renderWebGL(renderer)\n    // }\n\n    isModified(anim: boolean): boolean {\n        return false;\n    }\n\n    clearModify() {\n    }\n}\n","/// <reference path=\"types.d.ts\" />\n\nimport { ALPHA_MODES } from '@pixi/constants';\nimport { BaseTexture, Renderer, Texture, GLTexture, resources } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { Constant } from './Constant';\n\nexport interface IMultiTextureOptions {\n\tboundCountPerBuffer: number;\n\tboundSize: number;\n\tbufferSize: number;\n\tDO_CLEAR?: boolean;\n}\n\nexport class MultiTextureResource extends resources.Resource {\n\tconstructor(options: IMultiTextureOptions) {\n\t\tsuper(options.bufferSize, options.bufferSize);\n\n\t\tconst bounds = this.boundSprites;\n\t\tconst dirties = this.dirties;\n\t\tthis.boundSize = options.boundSize;\n\t\tfor (let j = 0; j < options.boundCountPerBuffer; j++) {\n\t\t\tconst spr = new Sprite();\n\t\t\tspr.position.x = options.boundSize * (j & 1);\n\t\t\tspr.position.y = options.boundSize * (j >> 1);\n\t\t\tbounds.push(spr);\n\t\t\tdirties.push(0);\n\t\t}\n\t\tthis.DO_CLEAR = !!options.DO_CLEAR;\n\t}\n\n\tDO_CLEAR = false;\n\tboundSize: number = 0;\n\t_clearBuffer: Uint8Array = null;\n\n\tbind(baseTexture: BaseTexture) {\n\t\tif (this.baseTex) {\n\t\t\tthrow new Error('Only one baseTexture is allowed for this resource!')\n\t\t}\n\t\tthis.baseTex = baseTexture;\n\t\tsuper.bind(baseTexture);\n\t}\n\n\tbaseTex: BaseTexture = null;\n\tboundSprites: Array<Sprite> = [];\n\tdirties: Array<number> = [];\n\n\tsetTexture(ind: number, texture: Texture) {\n\t\tconst spr = this.boundSprites[ind];\n\t\tif (spr.texture.baseTexture === texture.baseTexture) {\n\t\t\treturn;\n\t\t}\n\t\tspr.texture = texture;\n\t\tthis.baseTex.update();\n\t\tthis.dirties[ind] = (this.baseTex as any).dirtyId;\n\t}\n\n\tupload(renderer: Renderer, texture: BaseTexture, glTexture: GLTexture) {\n\t\tconst { gl } = renderer as any;\n\n\t\tconst {width, height} = this;\n\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.alphaMode === undefined ||\n\t\t\ttexture.alphaMode === ALPHA_MODES.UNPACK);\n\n\t\tif (glTexture.dirtyId < 0) {\n\t\t\t(glTexture as any).width = width;\n\t\t\t(glTexture as any).height = height;\n\n\t\t\tgl.texImage2D(texture.target, 0,\n\t\t\t\ttexture.format,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\t0,\n\t\t\t\ttexture.format,\n\t\t\t\ttexture.type,\n\t\t\t\tnull);\n\t\t}\n\n\t\tconst doClear = this.DO_CLEAR;\n\t\tif (doClear && !this._clearBuffer) {\n\t\t\tthis._clearBuffer = new Uint8Array(Constant.boundSize * Constant.boundSize * 4);\n\t\t}\n\n\t\tconst bounds = this.boundSprites;\n\t\tfor (let i = 0; i < bounds.length; i++) {\n\t\t\tconst spr = bounds[i];\n\t\t\tconst tex = spr.texture.baseTexture;\n\t\t\tif (glTexture.dirtyId >= this.dirties[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst res = tex.resource as any;\n\t\t\tif (!tex.valid || !res || !res.source) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (doClear && (tex.width < this.boundSize || tex.height < this.boundSize))\n\t\t\t{\n\t\t\t\tgl.texSubImage2D(texture.target, 0,\n\t\t\t\t\tspr.position.x,\n\t\t\t\t\tspr.position.y,\n\t\t\t\t\tthis.boundSize,\n\t\t\t\t\tthis.boundSize,\n\t\t\t\t\ttexture.format,\n\t\t\t\t\ttexture.type,\n\t\t\t\t\tthis._clearBuffer);\n\t\t\t}\n\t\t\tgl.texSubImage2D(texture.target, 0,\n\t\t\t\tspr.position.x,\n\t\t\t\tspr.position.y,\n\t\t\t\ttexture.format,\n\t\t\t\ttexture.type,\n\t\t\t\tres.source);\n\t\t}\n\n\t\treturn true;\n\t}\n}\n","import { Constant } from './Constant';\n\nimport type { TilemapShader } from './RectTileShader';\n\n\nexport function fillSamplers(shader: TilemapShader, maxTextures: number) {\n    let sampleValues: Array<number> = [];\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n    shader.uniforms.uSamplers = sampleValues;\n\n    let samplerSize: Array<number> = [];\n    for (let i = 0; i < maxTextures; i++) {\n        samplerSize.push(1.0 / Constant.bufferSize);\n        samplerSize.push(1.0 / Constant.bufferSize);\n    }\n    shader.uniforms.uSamplerSize = samplerSize;\n}\n\nexport function generateFragmentSrc(maxTextures: number, fragmentSrc: string) {\n    return fragmentSrc.replace(/%count%/gi, maxTextures + \"\")\n        .replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n}\n\nexport function generateSampleSrc(maxTextures: number) {\n    let src = '';\n\n    src += '\\n';\n    src += '\\n';\n\n    src += 'if(vTextureId <= -1.0) {';\n    src += '\\n\\tcolor = shadowColor;';\n    src += '\\n}';\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        src += '\\nelse ';\n\n        if(i < maxTextures-1)\n        {\n            src += 'if(textureId == ' + i + '.0)';\n        }\n\n        src += '\\n{';\n        src += '\\n\\tcolor = texture2D(uSamplers['+i+'], textureCoord * uSamplerSize['+i+']);';\n        src += '\\n}';\n    }\n\n    src += '\\n';\n    src += '\\n';\n\n    return src;\n}\n","/// <reference path=\"types.d.ts\" />\n\nimport * as shaderGenerator from './shaderGenerator';\n\nimport { Buffer, Geometry, Shader } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\n\nlet rectShaderFrag = `\nvarying vec2 vTextureCoord;\nvarying vec4 vFrame;\nvarying float vTextureId;\nuniform vec4 shadowColor;\nuniform sampler2D uSamplers[%count%];\nuniform vec2 uSamplerSize[%count%];\n\nvoid main(void){\n   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n   float textureId = floor(vTextureId + 0.5);\n\n   vec4 color;\n   %forloop%\n   gl_FragColor = color;\n}\n`;\nlet rectShaderVert = `\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aFrame;\nattribute vec2 aAnim;\nattribute float aTextureId;\n\nuniform mat3 projTransMatrix;\nuniform vec2 animationFrame;\n\nvarying vec2 vTextureCoord;\nvarying float vTextureId;\nvarying vec4 vFrame;\n\nvoid main(void){\n   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vec2 animCount = floor((aAnim + 0.5) / 2048.0);\n   vec2 animFrameOffset = aAnim - animCount * 2048.0;\n   vec2 animOffset = animFrameOffset * floor(mod(animationFrame + 0.5, animCount));\n\n   vTextureCoord = aTextureCoord + animOffset;\n   vFrame = aFrame + vec4(animOffset, animOffset);\n   vTextureId = aTextureId;\n}\n`;\n\nexport abstract class TilemapShader extends Shader {\n\tmaxTextures = 0;\n\n\tconstructor(maxTextures: number, shaderVert: string, shaderFrag: string) {\n\t\tsuper(\n\t\t\tnew PIXI.Program(\n\t\t\t\tshaderVert,\n\t\t\t\tshaderFrag),\n\t\t\t{\n\t\t\t\tanimationFrame: new Float32Array(2),\n\t\t\t\tuSamplers: [],\n\t\t\t\tuSamplerSize: [],\n\t\t\t\tprojTransMatrix: new Matrix()\n\t\t\t}\n\t\t);\n\t\tthis.maxTextures = maxTextures;\n\t\tshaderGenerator.fillSamplers(this, this.maxTextures);\n\t}\n}\n\nexport class RectTileShader extends TilemapShader {\n\tconstructor(maxTextures: number) {\n\t\tsuper(\n\t\t\tmaxTextures,\n\t\t\trectShaderVert,\n\t\t\tshaderGenerator.generateFragmentSrc(maxTextures, rectShaderFrag)\n\t\t);\n\t\tshaderGenerator.fillSamplers(this, this.maxTextures);\n\t}\n}\n\nexport class RectTileGeom extends Geometry {\n\tvertSize = 11;\n\tvertPerQuad = 4;\n\tstride = this.vertSize * 4;\n\tlastTimeAccess = 0;\n\n\tconstructor() {\n\t\tsuper();\n\t\tconst buf = this.buf = new Buffer(new Float32Array(2), true, false);\n\t\tthis.addAttribute('aVertexPosition', buf, 0, false, 0, this.stride, 0)\n\t\t\t.addAttribute('aTextureCoord', buf, 0, false, 0, this.stride, 2 * 4)\n\t\t\t.addAttribute('aFrame', buf, 0, false, 0, this.stride, 4 * 4)\n\t\t\t.addAttribute('aAnim', buf, 0, false, 0, this.stride, 8 * 4)\n\t\t\t.addAttribute('aTextureId', buf, 0, false, 0, this.stride, 10 * 4);\n\t}\n\n\tbuf: PIXI.Buffer;\n}","import { WRAP_MODES } from '@pixi/constants';\nimport { BaseTexture, Buffer, resources, ObjectRenderer, Texture, Renderer } from '@pixi/core';\nimport { Constant } from './Constant';\nimport { RectTileGeom, RectTileShader } from './RectTileShader';\nimport { MultiTextureResource } from './MultiTextureResource';\n\nimport type { TilemapShader } from './RectTileShader';\n\n/**\n * Renderer for rectangle tiles.\n */\nexport class TileRenderer extends ObjectRenderer {\n\trenderer: Renderer;\n\tgl: WebGLRenderingContext;\n\tsn: number = -1;\n\tindexBuffer: PIXI.Buffer = null;\n\tibLen: number = 0;\n\ttileAnim = [0, 0];\n\ttexLoc: Array<number> = [];\n\n\trectShader: RectTileShader;\n\ttexResources: Array<MultiTextureResource> = [];\n\n\tconstructor(renderer: Renderer) {\n\t\tsuper(renderer);\n\t\tthis.rectShader = new RectTileShader(Constant.maxTextures);\n\t\tthis.indexBuffer = new Buffer(undefined, true, true);\n\t\tthis.checkIndexBuffer(2000);\n\t\tthis.initBounds();\n\t}\n\n\tinitBounds() {\n\t\tif (Constant.boundCountPerBuffer <= 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst maxTextures = Constant.maxTextures;\n\t\tfor (let i = 0; i < maxTextures; i++) {\n\t\t\tconst resource = new MultiTextureResource(Constant);\n\t\t\tconst baseTex = new BaseTexture(resource);\n\t\t\tbaseTex.scaleMode = Constant.SCALE_MODE;\n\t\t\tbaseTex.wrapMode = WRAP_MODES.CLAMP;\n\t\t\tthis.texResources.push(resource);\n\t\t}\n\t}\n\n\tbindTexturesWithoutRT(renderer: Renderer, shader: TilemapShader, textures: Array<Texture>) {\n\t\tlet samplerSize: Array<number> = (shader as any).uniforms.uSamplerSize;\n\t\tthis.texLoc.length = 0;\n\t\tfor (let i = 0; i < textures.length; i++) {\n\t\t\tconst texture = textures[i];\n\t\t\tif (!texture || !texture.valid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trenderer.texture.bind(textures[i], i);\n\t\t\t//TODO: add resolution here\n\t\t\tsamplerSize[i * 2] = 1.0 / textures[i].baseTexture.width;\n\t\t\tsamplerSize[i * 2 + 1] = 1.0 / textures[i].baseTexture.height;\n\t\t}\n\t\t(shader as any).uniforms.uSamplerSize = samplerSize;\n\t}\n\n\tbindTextures(renderer: Renderer, shader: TilemapShader, textures: Array<Texture>) {\n\t\tconst len = textures.length;\n\t\tconst maxTextures = Constant.maxTextures;\n\t\tif (len > Constant.boundCountPerBuffer * maxTextures) {\n\t\t\treturn;\n\t\t}\n\t\tif (Constant.boundCountPerBuffer <= 1) {\n\t\t\tthis.bindTexturesWithoutRT(renderer, shader, textures);\n\t\t\treturn;\n\t\t}\n\n\t\tlet i = 0;\n\t\tfor (; i < len; i++) {\n\t\t\tconst texture = textures[i];\n\t\t\tif (!texture || !texture.valid) continue;\n\t\t\tconst multi = this.texResources[i >> 2];\n\t\t\tmulti.setTexture(i & 3, texture);\n\t\t}\n\n\t\tlet gltsUsed = (i + 3) >> 2;\n\t\tfor (i = 0; i < gltsUsed; i++) {\n\t\t\t//remove \"i, true\" after resolving a bug\n\t\t\trenderer.texture.bind(this.texResources[i].baseTex, i);\n\t\t}\n\t}\n\n\tstart() {\n\t\t//sorry, nothing\n\t}\n\n\tcreateVb() {\n\t\tconst geom = new RectTileGeom();\n\t\tgeom.addIndex(this.indexBuffer);\n\t\tgeom.lastTimeAccess = Date.now();\n\t\treturn geom;\n\t}\n\n\tcheckIndexBuffer(size: number, vb: RectTileGeom = null) {\n\t\tconst totalIndices = size * 6;\n\n\t\tif (totalIndices <= this.ibLen) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet len = totalIndices;\n\t\twhile (len < totalIndices) {\n\t\t\tlen <<= 1;\n\t\t}\n\n\t\tthis.ibLen = totalIndices;\n\t\tthis.indexBuffer.update((PIXI as any).utils.createIndicesForQuads(size,\n\t\t\tConstant.use32bitIndex ? new Uint32Array(size * 6) : undefined));\n\n\t\t// \tTODO: create new index buffer instead?\n\t\t// if (vb) {\n\t\t// \tconst curIndex = vb.getIndex();\n\t\t// \tif (curIndex !== this.indexBuffer && (curIndex.data as any).length < totalIndices) {\n\t\t// \t\tthis.swapIndex(vb, this.indexBuffer);\n\t\t// \t}\n\t\t// }\n\t}\n\n\t// swapIndex(geom: PIXI.Geometry, indexBuf: PIXI.Buffer) {\n\t\t// let buffers = (geom as any).buffers;\n\t\t// const oldIndex = geom.getIndex();\n\t\t// let ind = buffers.indexOf(oldIndex);\n\t\t// if (ind >= 0) {\n\t\t// \tbuffers.splice(ind, 1);\n\t\t// }\n\t\t// geom.addIndex(indexBuf);\n\t// }\n\n\tgetShader(): TilemapShader {\n\t\treturn this.rectShader;\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\t// this.rectShader.destroy();\n\t\tthis.rectShader = null;\n\t}\n}\n\nRenderer.registerPlugin('tilemap', TileRenderer as any);\n","/// <reference types=\"pixi.js\" />\n\nnamespace pixi_tilemap {\n    (PIXI as any).tilemap = pixi_tilemap;\n}\n\n// This makes exporter.ts a module!\nexport default {}\n","/// <reference path=\"types.d.ts\" />\n\nimport { Container } from '@pixi/display';\n\nimport type { CompositeRectTileLayer } from './CompositeRectTileLayer';\nimport type { Matrix } from '@pixi/math';\n\nexport class ZLayer extends Container {\n\n    constructor(tilemap: Container, zIndex: number) {\n        super();\n        this.tilemap = tilemap;\n        this.z = zIndex;\n    }\n\n    tilemap: any;\n    z: number;\n    zIndex: number;\n    _previousLayers: number;\n    canvasBuffer: HTMLCanvasElement;\n    _tempRender: any;\n    _lastAnimationFrame: number = -1;\n    layerTransform: Matrix;\n\n    clear() {\n        let layers = this.children as Array<CompositeRectTileLayer>;\n        for (let i = 0; i < layers.length; i++)\n            layers[i].clear();\n        this._previousLayers = 0;\n    }\n\n    cacheIfDirty() {\n        let tilemap: any = this.tilemap;\n        let layers = this.children as Array<CompositeRectTileLayer>;\n        let modified = this._previousLayers !== layers.length;\n        this._previousLayers = layers.length;\n        let buf = this.canvasBuffer;\n        let tempRender = this._tempRender;\n        if (!buf) {\n            buf = this.canvasBuffer = document.createElement('canvas');\n            tempRender = this._tempRender = new (PIXI as any).CanvasRenderer(100, 100, {view: buf});\n            tempRender.context = tempRender.rootContext;\n            tempRender.plugins.tilemap.dontUseTransform = true;\n        }\n        if (buf.width !== tilemap._layerWidth ||\n            buf.height !== tilemap._layerHeight) {\n            buf.width = tilemap._layerWidth;\n            buf.height = tilemap._layerHeight;\n            modified = true;\n        }\n        let i: number;\n        if (!modified) {\n            for (i = 0; i < layers.length; i++) {\n                if (layers[i].isModified(this._lastAnimationFrame !== tilemap.animationFrame)) {\n                    modified = true;\n                    break;\n                }\n            }\n        }\n        this._lastAnimationFrame = tilemap.animationFrame;\n        if (modified) {\n            if (tilemap._hackRenderer) {\n                tilemap._hackRenderer(tempRender);\n            }\n            tempRender.context.clearRect(0, 0, buf.width, buf.height);\n            for (i = 0; i < layers.length; i++) {\n                layers[i].clearModify();\n                layers[i].renderCanvas(tempRender);\n            }\n        }\n        this.layerTransform = this.worldTransform;\n        for (i = 0; i < layers.length; i++) {\n            this.layerTransform = layers[i].worldTransform;\n            break;\n        }\n    }\n\n    renderCanvas(renderer: any) {\n        this.cacheIfDirty();\n        let wt = this.layerTransform;\n        renderer.context.setTransform(\n            wt.a,\n            wt.b,\n            wt.c,\n            wt.d,\n            wt.tx * renderer.resolution,\n            wt.ty * renderer.resolution\n        );\n        let tilemap = this.tilemap;\n        renderer.context.drawImage(this.canvasBuffer, 0, 0);\n    }\n}\n","import { CanvasTileRenderer } from './CanvasTileRenderer';\nimport { CompositeRectTileLayer } from './CompositeRectTileLayer';\nimport { Constant } from './Constant';\nimport { GraphicsLayer } from './GraphicsLayer';\nimport { MultiTextureResource } from './MultiTextureResource';\nimport { RectTileLayer } from './RectTileLayer';\nimport { TilemapShader, RectTileShader, RectTileGeom } from './RectTileShader';\nimport { TileRenderer } from './TileRenderer';\nimport { ZLayer } from './ZLayer';\n\nexport const pixi_tilemap = {\n    CanvasTileRenderer,\n    CompositeRectTileLayer,\n    Constant,\n    GraphicsLayer,\n    MultiTextureResource,\n    RectTileLayer,\n    TilemapShader,\n    RectTileShader,\n    RectTileGeom,\n    TileRenderer,\n    ZLayer,\n};\n\nexport * from './CanvasTileRenderer';\nexport * from './CompositeRectTileLayer';\nexport * from './Constant';\nexport * from './exporter';\nexport * from './GraphicsLayer';\nexport * from './MultiTextureResource';\nexport * from './RectTileLayer';\nexport * from './RectTileShader';\nexport * from './shaderGenerator';\nexport * from './TileRenderer';\nexport * from './ZLayer';"],"names":["renderer","this","tileAnim","cr","PIXI","CanvasRenderer","registerPlugin","CanvasTileRenderer","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","Constant","maxTextures","bufferSize","boundSize","boundCountPerBuffer","use32bitIndex","SCALE_MODE","SCALE_MODES","LINEAR","DO_CLEAR","zIndex","texture","_super","_this","Float32Array","initialize","RectTileLayer","textures","baseTexture","pointsBuf","length","modificationMarker","hasAnim","texture_","x","y","animX","animY","textureIndex","Texture","from","found","textureList","i","addRect","frame","orig","width","height","rotate","u","v","tileWidth","tileHeight","animCountX","animCountY","pb","push","offset","count","plugins","tilemap","dontUseTransform","wt","worldTransform","context","setTransform","a","c","tx","resolution","ty","renderCanvasCore","points","fillStyle","n","x1","y1","x2","y2","w","h","drawImage","getDrawableSource","globalAlpha","fillRect","vb","destroy","plugin","shader","getShader","batch","setObjectRenderer","_globalMat","uniforms","projTransMatrix","globalUniforms","projectionMatrix","copyTo","append","shadowColor","animationFrame","renderWebGLCore","rectsCount","bindTextures","bind","createVb","vbId","id","vbBuffer","checkIndexBuffer","vertexBuf","getBuffer","vertices","vertPerQuad","vs","stride","byteLength","bk","ArrayBuffer","vbArray","vbInts","Uint32Array","update","arr","sz","textureId","shiftU","offsetX","shiftV","offsetY","compositeParent","animXEncoded","animYEncoded","u0","v0","u1","v1","u2","v2","u3","v3","w2","h2","cX","cY","groupD8","add","NW","uX","uY","geometry","draw","DRAW_MODES","TRIANGLES","anim","options","destroyVb","Container","bitmaps","texPerChild","apply","arguments","CompositeRectTileLayer","displayObjectUpdateTransform","z","setBitmaps","i_1","Error","len1","children","len2","Math","ceil","slice","layer","addChild","clear","animWidth","animHeight","childIndex","_lastLayer","tileRotate","tileAnimX","tileAnimY","ind","tex","child","j","visible","worldAlpha","renderable","layers","isModified","clearModify","GraphicsLayer","transform","Matrix","IDENTITY","graphics","render","Graphics","bounds","boundSprites","dirties","spr","Sprite","position","MultiTextureResource","baseTex","dirtyId","glTexture","gl","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","undefined","alphaMode","ALPHA_MODES","UNPACK","texImage2D","target","format","type","doClear","_clearBuffer","Uint8Array","res","resource","valid","source","texSubImage2D","resources","Resource","fillSamplers","sampleValues","uSamplers","samplerSize","uSamplerSize","generateFragmentSrc","fragmentSrc","replace","generateSampleSrc","shaderVert","shaderFrag","Program","shaderGenerator.fillSamplers","Shader","shaderGenerator.generateFragmentSrc","TilemapShader","vertSize","buf","Buffer","addAttribute","Geometry","rectShader","RectTileShader","indexBuffer","initBounds","TileRenderer","BaseTexture","scaleMode","wrapMode","WRAP_MODES","CLAMP","texResources","texLoc","len","bindTexturesWithoutRT","setTexture","gltsUsed","geom","RectTileGeom","addIndex","lastTimeAccess","Date","now","size","totalIndices","ibLen","utils","createIndicesForQuads","ObjectRenderer","pixi_tilemap","ZLayer","_previousLayers","modified","canvasBuffer","tempRender","_tempRender","document","createElement","view","rootContext","_layerWidth","_layerHeight","_lastAnimationFrame","_hackRenderer","clearRect","renderCanvas","layerTransform","cacheIfDirty","src"],"mappings":"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"}