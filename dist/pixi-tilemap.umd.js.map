{"version":3,"file":"pixi-tilemap.umd.js","sources":["../src/CanvasTileRenderer.ts","../src/const.ts","../src/Tilemap.ts","../src/CompositeTilemap.ts","../src/MultiTextureResource.ts","../src/shaderGenerator.ts","../src/TilemapShader.ts","../src/TileRenderer.ts","../src/index.ts"],"sourcesContent":["import type { AbstractRenderer } from '@pixi/core';\n\n/**\n * The renderer plugin for canvas. It isn't registered by default.\n *\n * ```\n * import { CanvasTileRenderer } from '@pixi/tilemap';\n * import { CanvasRenderer } from '@pixi/canvas-core';\n *\n * // You must register this yourself (optional). @pixi/tilemap doesn't do it to\n * // prevent a hard dependency on @pixi/canvas-core.\n * CanvasRenderer.registerPlugin('tilemap', CanvasTileRenderer);\n * ```\n */\n// TODO: Move to @pixi/tilemap-canvas\nexport class CanvasTileRenderer\n{\n    /** The renderer */\n    renderer: AbstractRenderer;\n\n    /** The global tile animation state */\n    tileAnim = [0, 0];\n\n    /** @deprecated */\n    dontUseTransform = false;\n\n    /** @param renderer */\n    constructor(renderer: AbstractRenderer)\n    {\n        this.renderer = renderer;\n        this.tileAnim = [0, 0];\n    }\n}\n","import { SCALE_MODES } from '@pixi/constants';\n\nexport const Constant = {\n    maxTextures: 16,\n    bufferSize: 2048,\n    boundSize: 1024,\n    boundCountPerBuffer: 1,\n    use32bitIndex: false,\n    SCALE_MODE: SCALE_MODES.LINEAR,\n    DO_CLEAR: true\n};\n","import { Container, Bounds } from '@pixi/display';\nimport { Constant } from './const';\nimport { DRAW_MODES } from '@pixi/constants';\nimport { Texture, Renderer } from '@pixi/core';\nimport { TileRenderer } from './TileRenderer';\nimport { Matrix, Rectangle, groupD8 } from '@pixi/math';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { RectTileGeom } from './TilemapShader';\n\nexport const POINT_STRUCT_SIZE = 12;\n\n/**\n * A rectangular tilemap implementation that renders a predefined set of tile textures.\n *\n * The {@link Tilemap.tileset tileset} of a tilemap defines the list of textures that can be painted in the\n * tilemap. The texture is identified using its index into the this list, i.e. changing the texture at a given\n * index in the tileset modifies the paint of all tiles pointing to that index.\n *\n * The size of the tileset is limited by the texture units supported by the client device. The minimum supported\n * value is 8, as defined by the WebGL 1 specification. `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS`) can be used\n * to extract this limit. {@link CompositeTilemap} can be used to get around this limit by layering multiple tilemap\n * instances.\n *\n * @example\n * import { Tilemap } from '@pixi/tilemap';\n * import { Loader } from '@pixi/loaders';\n *\n * // Add the spritesheet into your loader!\n * Loader.shared.add('atlas', 'assets/atlas.json');\n *\n * // Make the tilemap once the tileset assets are available.\n * Loader.shared.load(function onTilesetLoaded()\n * {\n *      // These textures should've been in the spritesheet. If you don't\n *      // use a spritesheet, this technique will still work as long as\n *      // each individual texture is served.\n *      const tilemap = new Tilemap([\n *          Texture.from('grass.png'),\n *          Texture.from('tough.png'),\n *          Texture.from('brick.png'),\n *          Texture.from('brick_wall.png'),\n *          Texture.from('chest.png')\n *      ])\n *      // Now you defined each tile to generate the tilemap!\n *          .tile('grass.png', 0, 0)\n *          .tile('grass.png', 100, 100)\n *          .tile('brick_wall.png', 0, 100);\n * });\n */\nexport class Tilemap extends Container\n{\n    // zIndex to zero by DisplayObject\n    modificationMarker = 0;\n    shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    _globalMat: Matrix = null;\n    hasAnim = false;\n    offsetX = 0;\n    offsetY = 0;\n    compositeParent = false;\n    tileAnim: Array<number> = null;\n\n    /**\n     * The list of textures being used in the tilemap.\n     *\n     * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\n     * should be added after tiles have been added into the map.\n     */\n    protected tileset: Array<Texture>;\n\n    /**\n     * The local bounds of the tilemap itself. This does not include DisplayObject children.\n     */\n    protected readonly tilemapBounds = new Bounds();\n\n    private pointsBuf: Array<number> = [];\n\n    /**\n     * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}.\n     */\n    constructor(tileset: Texture | Array<Texture>);\n    constructor(zIndex: number, textures: Texture | Array<Texture>);\n\n    constructor(arg0: Texture | Array<Texture> | number, arg1?: Texture | Array<Texture>)\n    {\n        super();\n\n        const zIndex = typeof arg0 === 'number' ? arg0 : 0;\n        const tileset = typeof arg0 !== 'number' ? arg0 : arg1;\n\n        this.zIndex = zIndex;\n        this.setTileset(tileset);\n    }\n\n    /**\n     * @returns The tileset of this tilemap.\n     */\n    getTileset(): Array<Texture>\n    {\n        return this.tileset;\n    }\n\n    /**\n     * Define the tileset used by the tilemap.\n     *\n     * @param tileset - The list of textures to use in the tilemap. If a texture (not array) is passed, it will\n     *  be wrapped into an array.\n     */\n    setTileset(tileset: Texture | Array<Texture> = []): this\n    {\n        if (!Array.isArray(tileset))\n        {\n            tileset = [tileset];\n        }\n\n        this.tileset = tileset;\n\n        return this;\n    }\n\n    /**  Clears all the tiles added into this tilemap. */\n    clear(): this\n    {\n        this.pointsBuf.length = 0;\n        this.modificationMarker = 0;\n        this.tilemapBounds.clear();\n        this.hasAnim = false;\n\n        return this;\n    }\n\n    /**\n     * Adds a tile that paints the given texture at (x, y).\n     *\n     * @param tileTexture - The tiling texture to render.\n     * @param x - The local x-coordinate of the tile's position.\n     * @param y - The local y-coordinate of the tile's position.\n     * @param options - Additional tile options.\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\n     * @param [options.animX=0]\n     * @param [options.animY=0]\n     * @param [options.rotate=0]\n     * @param [options.animCountX=1024]\n     * @param [options.animCountY=1024]\n     * @returns\n     */\n    tile(\n        tileTexture: number | string | Texture,\n        x: number,\n        y: number,\n        options: {\n            u?: number,\n            v?: number,\n            tileWidth?: number,\n            tileHeight?: number,\n            animX?: number,\n            animY?: number,\n            rotate?: number,\n            animCountX?: number,\n            animCountY?: number\n        }\n    ): this\n    {\n        let texture: Texture;\n        let textureIndex = -1;\n\n        if (typeof tileTexture === 'number')\n        {\n            textureIndex = tileTexture;\n            texture = this.tileset[textureIndex];\n        }\n        else\n        {\n            if (typeof tileTexture === 'string')\n            {\n                texture = Texture.from(tileTexture);\n            }\n            else\n            {\n                texture = tileTexture as Texture;\n            }\n\n            const textureList = this.tileset;\n\n            for (let i = 0; i < textureList.length; i++)\n            {\n                if (textureList[i].baseTexture === texture.baseTexture)\n                {\n                    textureIndex = i;\n                    break;\n                }\n            }\n        }\n\n        if (!texture || textureIndex < 0)\n        {\n            console.error('The tile texture was not found in the tilemap tileset.');\n\n            return this;\n        }\n\n        const {\n            u = texture.frame.x,\n            v = texture.frame.y,\n            tileWidth = texture.orig.width,\n            tileHeight = texture.orig.height,\n            animX = 0,\n            animY = 0,\n            rotate = 0,\n            animCountX = 1024,\n            animCountY = 1024,\n        } = options;\n\n        const pb = this.pointsBuf;\n\n        this.hasAnim = this.hasAnim || animX > 0 || animY > 0;\n\n        pb.push(u);\n        pb.push(v);\n        pb.push(x);\n        pb.push(y);\n        pb.push(tileWidth);\n        pb.push(tileHeight);\n        pb.push(rotate);\n        pb.push(animX | 0);\n        pb.push(animY | 0);\n        pb.push(textureIndex);\n        pb.push(animCountX);\n        pb.push(animCountY);\n\n        this.tilemapBounds.addFramePad(x, y, x + tileWidth, y + tileHeight, 0, 0);\n\n        return this;\n    }\n\n    /** Changes the rotation of the last tile. */\n    tileRotate(rotate: number): void\n    {\n        const pb = this.pointsBuf;\n\n        // This seems off.\n        pb[pb.length - 3] = rotate;\n    }\n\n    /** Changes the `animX`, `animCountX` of the last tile. */\n    tileAnimX(offset: number, count: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - 5] = offset;\n        pb[pb.length - 2] = count;\n    }\n\n    /** Changes the `animY`, `animCountY` of the last tile. */\n    tileAnimY(offset: number, count: number): void\n    {\n        const pb = this.pointsBuf;\n\n        pb[pb.length - 4] = offset;\n        pb[pb.length - 1] = count;\n    }\n\n    renderCanvas(renderer: CanvasRenderer): void\n    {\n        const plugin = renderer.plugins.tilemap;\n\n        if (plugin && !plugin.dontUseTransform)\n        {\n            const wt = this.worldTransform;\n\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                wt.tx * renderer.resolution,\n                wt.ty * renderer.resolution\n            );\n        }\n\n        this.renderCanvasCore(renderer);\n    }\n\n    renderCanvasCore(renderer: CanvasRenderer): void\n    {\n        if (this.tileset.length === 0) return;\n        const points = this.pointsBuf;\n        const tileAnim = this.tileAnim || (renderer.plugins.tilemap && renderer.plugins.tilemap.tileAnim);\n\n        renderer.context.fillStyle = '#000000';\n        for (let i = 0, n = points.length; i < n; i += POINT_STRUCT_SIZE)\n        {\n            let x1 = points[i]; let\n                y1 = points[i + 1];\n            const x2 = points[i + 2]; const\n                y2 = points[i + 3];\n            const w = points[i + 4];\n            const h = points[i + 5];\n            // const rotate = points[i + 6];\n\n            x1 += points[i + 7] * tileAnim[0];\n            y1 += points[i + 8] * tileAnim[1];\n            const textureIndex = points[i + 9];\n            // canvas does not work with rotate yet\n\n            if (textureIndex >= 0 && this.tileset[textureIndex])\n            {\n                renderer.context.drawImage(\n                    (this.tileset[textureIndex].baseTexture as any).getDrawableSource(),\n                    x1, y1, w, h, x2, y2, w, h\n                );\n            }\n            else\n            {\n                renderer.context.globalAlpha = 0.5;\n                renderer.context.fillRect(x2, y2, w, h);\n                renderer.context.globalAlpha = 1;\n            }\n        }\n    }\n\n    private vbId = 0;\n    private vb: RectTileGeom = null;\n    private vbBuffer: ArrayBuffer = null;\n    private vbArray: Float32Array = null;\n    private vbInts: Uint32Array = null;\n\n    private destroyVb(): void\n    {\n        if (this.vb)\n        {\n            this.vb.destroy();\n            this.vb = null;\n        }\n    }\n\n    render(renderer: Renderer): void\n    {\n        const plugin = (renderer.plugins as any).tilemap;\n        const shader = plugin.getShader();\n\n        renderer.batch.setObjectRenderer(plugin);\n        this._globalMat = shader.uniforms.projTransMatrix;\n        renderer\n            .globalUniforms\n            .uniforms\n            .projectionMatrix\n            .copyTo(this._globalMat)\n            .append(this.worldTransform);\n\n        shader.uniforms.shadowColor = this.shadowColor;\n        shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;\n\n        this.renderWebGLCore(renderer, plugin);\n    }\n\n    renderWebGLCore(renderer: Renderer, plugin: TileRenderer): void\n    {\n        const points = this.pointsBuf;\n\n        if (points.length === 0) return;\n        const rectsCount = points.length / POINT_STRUCT_SIZE;\n\n        const shader = plugin.getShader();\n        const textures = this.tileset;\n\n        if (textures.length === 0) return;\n\n        plugin.bindTextures(renderer, shader, textures);\n        renderer.shader.bind(shader, false);\n\n        // lost context! recover!\n        let vb = this.vb;\n\n        if (!vb)\n        {\n            vb = plugin.createVb();\n            this.vb = vb;\n            this.vbId = (vb as any).id;\n            this.vbBuffer = null;\n            this.modificationMarker = 0;\n        }\n\n        plugin.checkIndexBuffer(rectsCount, vb);\n        const boundCountPerBuffer = Constant.boundCountPerBuffer;\n\n        const vertexBuf = vb.getBuffer('aVertexPosition');\n        // if layer was changed, re-upload vertices\n        const vertices = rectsCount * vb.vertPerQuad;\n\n        if (vertices === 0) return;\n        if (this.modificationMarker !== vertices)\n        {\n            this.modificationMarker = vertices;\n            const vs = vb.stride * vertices;\n\n            if (!this.vbBuffer || this.vbBuffer.byteLength < vs)\n            {\n                // !@#$ happens, need resize\n                let bk = vb.stride;\n\n                while (bk < vs)\n                {\n                    bk *= 2;\n                }\n                this.vbBuffer = new ArrayBuffer(bk);\n                this.vbArray = new Float32Array(this.vbBuffer);\n                this.vbInts = new Uint32Array(this.vbBuffer);\n                vertexBuf.update(this.vbBuffer);\n            }\n\n            const arr = this.vbArray;\n            // const ints = this.vbInts;\n            // upload vertices!\n            let sz = 0;\n            // let tint = 0xffffffff;\n            let textureId = 0;\n            let shiftU: number = this.offsetX;\n            let shiftV: number = this.offsetY;\n\n            // let tint = 0xffffffff;\n            // const tint = -1;\n\n            for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE)\n            {\n                const eps = 0.5;\n\n                if (this.compositeParent)\n                {\n                    if (boundCountPerBuffer > 1)\n                    {\n                        // TODO: what if its more than 4?\n                        textureId = (points[i + 9] >> 2);\n                        shiftU = this.offsetX * (points[i + 9] & 1);\n                        shiftV = this.offsetY * ((points[i + 9] >> 1) & 1);\n                    }\n                    else\n                    {\n                        textureId = points[i + 9];\n                        shiftU = 0;\n                        shiftV = 0;\n                    }\n                }\n                const x = points[i + 2]; const\n                    y = points[i + 3];\n                const w = points[i + 4]; const\n                    h = points[i + 5];\n                const u = points[i] + shiftU; const\n                    v = points[i + 1] + shiftV;\n                let rotate = points[i + 6];\n\n                const animX = points[i + 7]; const\n                    animY = points[i + 8];\n                const animWidth = points[i + 10] || 1024; const\n                    animHeight = points[i + 11] || 1024;\n                const animXEncoded = animX + (animWidth * 2048);\n                const animYEncoded = animY + (animHeight * 2048);\n\n                let u0: number;\n                let v0: number; let u1: number;\n                let v1: number; let u2: number;\n                let v2: number; let u3: number;\n                let v3: number;\n\n                if (rotate === 0)\n                {\n                    u0 = u;\n                    v0 = v;\n                    u1 = u + w;\n                    v1 = v;\n                    u2 = u + w;\n                    v2 = v + h;\n                    u3 = u;\n                    v3 = v + h;\n                }\n                else\n                {\n                    let w2 = w / 2;\n                    let h2 = h / 2;\n\n                    if (rotate % 4 !== 0)\n                    {\n                        w2 = h / 2;\n                        h2 = w / 2;\n                    }\n                    const cX = u + w2;\n                    const cY = v + h2;\n\n                    rotate = groupD8.add(rotate, groupD8.NW);\n                    u0 = cX + (w2 * groupD8.uX(rotate));\n                    v0 = cY + (h2 * groupD8.uY(rotate));\n\n                    rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n                    u1 = cX + (w2 * groupD8.uX(rotate));\n                    v1 = cY + (h2 * groupD8.uY(rotate));\n\n                    rotate = groupD8.add(rotate, 2);\n                    u2 = cX + (w2 * groupD8.uX(rotate));\n                    v2 = cY + (h2 * groupD8.uY(rotate));\n\n                    rotate = groupD8.add(rotate, 2);\n                    u3 = cX + (w2 * groupD8.uX(rotate));\n                    v3 = cY + (h2 * groupD8.uY(rotate));\n                }\n\n                arr[sz++] = x;\n                arr[sz++] = y;\n                arr[sz++] = u0;\n                arr[sz++] = v0;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y;\n                arr[sz++] = u1;\n                arr[sz++] = v1;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y + h;\n                arr[sz++] = u2;\n                arr[sz++] = v2;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n                arr[sz++] = x;\n                arr[sz++] = y + h;\n                arr[sz++] = u3;\n                arr[sz++] = v3;\n                arr[sz++] = u + eps;\n                arr[sz++] = v + eps;\n                arr[sz++] = u + w - eps;\n                arr[sz++] = v + h - eps;\n                arr[sz++] = animXEncoded;\n                arr[sz++] = animYEncoded;\n                arr[sz++] = textureId;\n            }\n\n            vertexBuf.update(arr);\n        }\n\n        (renderer.geometry as any).bind(vb, shader);\n        renderer.geometry.draw(DRAW_MODES.TRIANGLES, rectsCount * 6, 0);\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    isModified(anim: boolean): boolean\n    {\n        if (this.modificationMarker !== this.pointsBuf.length\n            || (anim && this.hasAnim))\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * This will pull forward the modification marker.\n     *\n     * @internal\n     * @ignore\n     */\n    clearModify(): void\n    {\n        this.modificationMarker = this.pointsBuf.length;\n    }\n\n    /** @override */\n    protected _calculateBounds(): void\n    {\n        const { minX, minY, maxX, maxY } = this.tilemapBounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /** @override */\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            return this.tilemapBounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /** @override */\n    destroy(options?: IDestroyOptions): void\n    {\n        super.destroy(options);\n        this.destroyVb();\n    }\n\n    /**\n     * This initialization routine has been replaced by {@link Tilemap.setTileset setTileset}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     * @param zIndex - The z-index of the tilemap.\n     * @param textures - The tileset to use.\n     */\n    initialize(zIndex: number, textures: Texture | Array<Texture>): void\n    {\n        this.zIndex = zIndex || 0;\n        this.setTileset(textures);\n    }\n\n    /**\n     * Deprecated signature for {@link Tilemap.tile tile}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    addFrame(texture: Texture | string | number, x: number, y: number, animX: number, animY: number): boolean\n    {\n        this.tile(\n            texture,\n            x,\n            y,\n            {\n                animX,\n                animY,\n            }\n        );\n\n        return true;\n    }\n\n    /**\n     * Deprecated signature for {@link Tilemap.tile tile}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    // eslint-disable-next-line max-params\n    addRect(\n        textureIndex: number,\n        u: number,\n        v: number,\n        x: number,\n        y: number,\n        tileWidth: number,\n        tileHeight: number,\n        animX = 0,\n        animY = 0,\n        rotate = 0,\n        animCountX = 1024,\n        animCountY = 1024\n    ): this\n    {\n        return this.tile(\n            textureIndex,\n            x, y,\n            {\n                u, v, tileWidth, tileHeight, animX, animY, rotate, animCountX, animCountY\n            }\n        );\n    }\n}\n","import { Container } from '@pixi/display';\nimport { Texture, Renderer } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\nimport { Constant } from './const';\nimport { Tilemap } from './Tilemap';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { TileRenderer } from './TileRenderer';\n\n/**\n * A tilemap composite that lazily builds tilesets layered into multiple tilemaps.\n *\n * The composite tileset is the concatenatation of the individual tilesets used in the tilemaps. You can\n * preinitialized it by passing a list of tile textures to the constructor. Otherwise, the composite tilemap\n * is lazily built as you add more tiles with newer tile textures. A new tilemap is created once the last\n * tilemap has reached its limit (as set by {@link CompositeTilemap.texturesPerTilemap texturesPerTilemap}).\n *\n * @example\n * import { Application } from '@pixi/app';\n * import { CompositeTilemap } from '@pixi/tilemap';\n * import { Loader } from '@pixi/loaders';\n *\n * // Setup view & stage.\n * const app = new Application();\n *\n * document.body.appendChild(app.renderer.view);\n * app.stage.interactive = true;\n *\n * // Global reference to the tilemap.\n * let globalTilemap: CompositeTilemap;\n *\n * // Load the tileset spritesheet!\n * Loader.shared.load('atlas.json');\n *\n * // Initialize the tilemap scene when the assets load.\n * Loader.shared.load(function onTilesetLoaded()\n * {\n *      // Preinitialize with two most used textures\n *      const tilemap = new CompositeTilemap([\n *          Texture.from('grass.png'),\n *          Texture.from('dungeon.png'),\n *      ]);\n *\n *      // Setup the game level with grass and dungeons!\n *      for (let x = 0; x < 10; x++)\n *      {\n *          for (let y = 0; y < 10; y++)\n *          {\n *              tilemap.tile(\n *                  x % 2 === 0 && (x === y || x + y === 10) ? 'dungeon.png' : 'grass.png',\n *                  x * 100,\n *                  y * 100,\n *              );\n *          }\n *      }\n *\n *      globalTilemap = app.stage.addChild(tilemap);\n * });\n *\n * // Show a bomb at a random location whenever the user clicks!\n * app.stage.on('click', function onClick()\n * {\n *      if (!globalTilemap) return;\n *\n *      const x = Math.floor(Math.random() * 10);\n *      const y = Math.floor(Math.random() * 10);\n *\n *      globalTilemap.tile('bomb.png', x * 100, y * 100);\n * });\n */\nexport class CompositeTilemap extends Container\n{\n    /** The hard limit on the number of tile textures used in each tilemap. */\n    public readonly texturesPerTilemap: number;\n\n    /** The animation parameters */\n    public tileAnim: Array<number> = null;\n\n    /** The last modified tilemap. */\n    protected lastModifiedTilemap: Tilemap = null;\n\n    private modificationMarker = 0;\n    private shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    private _globalMat: Matrix = null;\n\n    /**\n     * @param tileset - A list of tile textures that will be used to eagerly initialized the layered\n     *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\n     *  will work equivalently.\n     * @param texturesPerTilemap - A custom limit on the number of tile textures used in each tilemap.\n     */\n    constructor(tileset?: Array<Texture>, texturesPerTilemap?: number);\n\n    // @deprecated\n    constructor(zIndex?: number, bitmaps?: Array<Texture>, texPerChild?: number);\n\n    constructor(bitmaps?: Array<Texture> | number, texPerChild?: Array<Texture> | number, arg2?: number)\n    {\n        super();\n\n        const zIndex = typeof bitmaps === 'number' ? bitmaps : 0;\n        // eslint-disable-next-line no-nested-ternary\n        const tileset = Array.isArray(bitmaps) ? bitmaps : (Array.isArray(texPerChild) ? texPerChild : null);\n        const texturesPerTilemap = typeof texPerChild === 'number' ? texPerChild : arg2;\n\n        this.zIndex = zIndex;\n        this.tileset(tileset);\n        this.texturesPerTilemap = texturesPerTilemap || Constant.boundCountPerBuffer * Constant.maxTextures;\n    }\n\n    /**\n     * This will preinitialize the tilesets of the layered tilemaps.\n     *\n     * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\n     * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\n     *\n     * @param tileTextures - The list of tile textures that make up the tileset.\n     */\n    tileset(tileTextures: Array<Texture>): this\n    {\n        if (!tileTextures)\n        {\n            tileTextures = [];\n        }\n\n        // Sanity check!\n        for (let i = 0; i < tileTextures.length; i++)\n        {\n            if (tileTextures[i] && !tileTextures[i].baseTexture)\n            {\n                throw new Error(`pixi-tilemap cannot use destroyed textures. `\n                    + `Probably, you passed resources['myAtlas'].texture in pixi > 5.2.1, it does not exist there.`);\n            }\n        }\n\n        const texPerChild = this.texturesPerTilemap;\n        const len1 = this.children.length;\n        const len2 = Math.ceil(tileTextures.length / texPerChild);\n\n        for (let i = 0; i < len1; i++)\n        {\n            (this.children[i] as Tilemap).setTileset(\n                tileTextures.slice(i * texPerChild, (i + 1) * texPerChild)\n            );\n        }\n        for (let i = len1; i < len2; i++)\n        {\n            const layer = new Tilemap(this.zIndex, tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));\n\n            layer.compositeParent = true;\n            layer.offsetX = Constant.boundSize;\n            layer.offsetY = Constant.boundSize;\n\n            this.addChild(layer);\n        }\n\n        return this;\n    }\n\n    /** Clears the tilemap composite. */\n    clear(): this\n    {\n        for (let i = 0; i < this.children.length; i++)\n        {\n            (this.children[i] as Tilemap).clear();\n        }\n\n        this.modificationMarker = 0;\n\n        return this;\n    }\n\n    /** Changes the rotation of the last added tile. */\n    tileRotate(rotate: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileRotate(rotate);\n        }\n\n        return this;\n    }\n\n    /** Changes `animX`, `animCountX` of the last added tile. */\n    tileAnimX(offset: number, count: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileAnimX(offset, count);\n        }\n\n        return this;\n    }\n\n    /** Changes `animY`, `animCountY` of the last added tile. */\n    tileAnimY(offset: number, count: number): this\n    {\n        if (this.lastModifiedTilemap)\n        {\n            this.lastModifiedTilemap.tileAnimY(offset, count);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a tile that paints the given tile texture at (x, y).\n     *\n     * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\n     * @param x - The local x-coordinate of the tile's location.\n     * @param y - The local y-coordinate of the tile's location.\n     * @param options - Additional options to pass to {@link Tilemap.tile}.\n     */\n    tile(\n        texture_: Texture | string | number,\n        x: number,\n        y: number,\n        options: {\n            u?: number,\n            v?: number,\n            tileWidth?: number,\n            tileHeight?: number,\n            animX?: number,\n            animY?: number,\n            rotate?: number,\n            animCountX?: number,\n            animCountY?: number\n        } = {}\n    ): this\n    {\n        let texture: Texture;\n        let layer: Tilemap = null;\n        let ind  = 0;\n        const children = this.children;\n\n        this.lastModifiedTilemap = null;\n\n        if (typeof texture_ === 'number')\n        {\n            const childIndex = texture_ / this.texturesPerTilemap >> 0;\n\n            layer = children[childIndex] as Tilemap;\n\n            if (!layer)\n            {\n                layer = children[0] as Tilemap;\n                if (!layer)\n                {\n                    return this;\n                }\n                ind = 0;\n            }\n            else\n            {\n                ind = texture_ % this.texturesPerTilemap;\n            }\n\n            texture = layer.getTileset()[ind];\n        }\n        else\n        {\n            if (typeof texture_ === 'string')\n            {\n                texture = Texture.from(texture_);\n            }\n            else\n            {\n                texture = texture_ as Texture;\n            }\n\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i] as Tilemap;\n                const tex = child.getTileset();\n\n                for (let j = 0; j < tex.length; j++)\n                {\n                    if (tex[j].baseTexture === texture.baseTexture)\n                    {\n                        layer = child;\n                        ind = j;\n                        break;\n                    }\n                }\n                if (layer)\n                {\n                    break;\n                }\n            }\n\n            if (!layer)\n            {\n                for (let i = 0; i < children.length; i++)\n                {\n                    const child = children[i] as Tilemap;\n\n                    if (child.getTileset().length < this.texturesPerTilemap)\n                    {\n                        layer = child;\n                        ind = child.getTileset().length;\n                        child.getTileset().push(texture);\n                        break;\n                    }\n                }\n                if (!layer)\n                {\n                    layer = new Tilemap(this.zIndex, texture);\n                    layer.compositeParent = true;\n                    layer.offsetX = Constant.boundSize;\n                    layer.offsetY = Constant.boundSize;\n                    this.addChild(layer);\n                    ind = 0;\n                }\n            }\n        }\n\n        this.lastModifiedTilemap = layer;\n        layer.tile(\n            ind,\n            x,\n            y,\n            options,\n        );\n\n        return this;\n    }\n\n    renderCanvas(renderer: CanvasRenderer): void\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        const tilemapPlugin = renderer.plugins.tilemap;\n\n        if (tilemapPlugin && !tilemapPlugin.dontUseTransform)\n        {\n            const wt = this.worldTransform;\n\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                wt.tx * renderer.resolution,\n                wt.ty * renderer.resolution\n            );\n        }\n\n        const layers = this.children;\n\n        for (let i = 0; i < layers.length; i++)\n        {\n            const layer = (layers[i] as Tilemap);\n\n            layer.tileAnim = this.tileAnim;\n            layer.renderCanvasCore(renderer);\n        }\n    }\n\n    render(renderer: Renderer): void\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        const plugin = renderer.plugins.tilemap as TileRenderer;\n        const shader = plugin.getShader();\n\n        renderer.batch.setObjectRenderer(plugin);\n\n        // TODO: dont create new array, please\n        this._globalMat = shader.uniforms.projTransMatrix;\n        renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);\n        shader.uniforms.shadowColor = this.shadowColor;\n        shader.uniforms.animationFrame = this.tileAnim || plugin.tileAnim;\n\n        renderer.shader.bind(shader, false);\n\n        const layers = this.children;\n\n        for (let i = 0; i < layers.length; i++)\n        {\n            (layers[i] as Tilemap).renderWebGLCore(renderer, plugin);\n        }\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    isModified(anim: boolean): boolean\n    {\n        const layers = this.children;\n\n        if (this.modificationMarker !== layers.length)\n        {\n            return true;\n        }\n        for (let i = 0; i < layers.length; i++)\n        {\n            if ((layers[i] as Tilemap).isModified(anim))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    clearModify(): void\n    {\n        const layers = this.children;\n\n        this.modificationMarker = layers.length;\n        for (let i = 0; i < layers.length; i++)\n        {\n            (layers[i] as Tilemap).clearModify();\n        }\n    }\n\n    /**\n     * @deprecated Since @pixi/tilemap 3.\n     * @see CompositeTilemap.tile\n     */\n    addFrame(\n        texture: Texture | string | number,\n        x: number,\n        y: number,\n        animX?: number,\n        animY?: number,\n        animWidth?: number,\n        animHeight?: number\n    ): this\n    {\n        return this.tile(\n            texture,\n            x, y,\n            {\n                animX,\n                animY,\n                animCountX: animWidth,\n                animCountY: animHeight,\n            }\n        );\n    }\n\n    /**\n     * @deprecated @pixi/tilemap 3\n     * @see CompositeTilemap.tile\n     */\n    // eslint-disable-next-line max-params\n    addRect(\n        textureIndex: number,\n        u: number,\n        v: number,\n        x: number,\n        y: number,\n        tileWidth: number,\n        tileHeight: number,\n        animX?: number,\n        animY?: number,\n        rotate?: number,\n        animWidth?: number,\n        animHeight?: number\n    ): this\n    {\n        const childIndex: number = textureIndex / this.texturesPerTilemap >> 0;\n        const textureId: number = textureIndex % this.texturesPerTilemap;\n\n        if (this.children[childIndex] && (this.children[childIndex] as Tilemap).getTileset())\n        {\n            this.lastModifiedTilemap = (this.children[childIndex] as Tilemap);\n            this.lastModifiedTilemap.addRect(\n                textureId, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight\n            );\n        }\n        else\n        {\n            this.lastModifiedTilemap = null;\n        }\n\n        return this;\n    }\n\n    /**\n     * This initialization routine is now done in the constructor.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     * @param zIndex - The z-index of the tilemap composite.\n     * @param bitmaps - The tileset to use.\n     * @param texPerChild - The number of textures per tilemap.\n     */\n    initialize(zIndex?: number, bitmaps?: Array<Texture>, texPerChild?: number): void\n    {\n        if (texPerChild as any === true)\n        {\n            // old format, ignore it!\n            texPerChild = 0;\n        }\n\n        this.zIndex = zIndex;\n        (this as any).texturesPerTilemap = texPerChild || Constant.boundCountPerBuffer * Constant.maxTextures;\n\n        if (bitmaps)\n        {\n            this.tileset(bitmaps);\n        }\n    }\n\n    /**\n     * Alias for {@link CompositeTilemap.tileset tileset}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    setBitmaps = this.tileset;\n\n    /**\n     * @deprecated Since @pixi/tilemap 3.\n     * @readonly\n     * @see CompositeTilemap.texturesPerTilemap\n     */\n    get texPerChild(): number { return this.texturesPerTilemap; }\n}\n","import { ALPHA_MODES } from '@pixi/constants';\nimport { BaseTexture, Renderer, Resource, Texture, GLTexture } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { Constant } from './const';\n\nexport interface IMultiTextureOptions\n{\n\tboundCountPerBuffer: number;\n\tboundSize: number;\n\tbufferSize: number;\n\tDO_CLEAR?: boolean;\n}\n\n// For some reason ESLint goes mad with indendation in this file ^&^\n/* eslint-disable indent */\n\n/**\n * @internal\n * @ignore\n */\nexport class MultiTextureResource extends Resource\n{\n\tpublic baseTex: BaseTexture = null;\n\n\tprivate DO_CLEAR = false;\n\tprivate boundSize = 0;\n\tprivate _clearBuffer: Uint8Array = null;\n\tprivate boundSprites: Array<Sprite> = [];\n\tprivate dirties: Array<number> = [];\n\n\tconstructor(options: IMultiTextureOptions)\n\t{\n\t\tsuper(options.bufferSize, options.bufferSize);\n\n\t\tconst bounds = this.boundSprites;\n\t\tconst dirties = this.dirties;\n\n\t\tthis.boundSize = options.boundSize;\n\n\t\tfor (let j = 0; j < options.boundCountPerBuffer; j++)\n\t\t{\n\t\t\tconst spr = new Sprite();\n\n\t\t\tspr.position.x = options.boundSize * (j & 1);\n\t\t\tspr.position.y = options.boundSize * (j >> 1);\n\t\t\tbounds.push(spr);\n\t\t\tdirties.push(0);\n\t\t}\n\n\t\tthis.DO_CLEAR = !!options.DO_CLEAR;\n\t}\n\n\tbind(baseTexture: BaseTexture): void\n\t{\n\t\tif (this.baseTex)\n\t\t{\n\t\t\tthrow new Error('Only one baseTexture is allowed for this resource!');\n\t\t}\n\t\tthis.baseTex = baseTexture;\n\t\tsuper.bind(baseTexture);\n\t}\n\tsetTexture(ind: number, texture: Texture): void\n\t{\n\t\tconst spr = this.boundSprites[ind];\n\n\t\tif (spr.texture.baseTexture === texture.baseTexture)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tspr.texture = texture;\n\t\tthis.baseTex.update();\n\t\tthis.dirties[ind] = (this.baseTex as any).dirtyId;\n\t}\n\n\tupload(renderer: Renderer, texture: BaseTexture, glTexture: GLTexture): boolean\n\t{\n\t\tconst { gl } = renderer as any;\n\n\t\tconst { width, height } = this;\n\n\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.alphaMode === undefined\n\t|| texture.alphaMode === ALPHA_MODES.UNPACK);\n\n\t\tif (glTexture.dirtyId < 0)\n\t\t{\n\t\t\t(glTexture as any).width = width;\n\t\t\t(glTexture as any).height = height;\n\n\t\t\tgl.texImage2D(texture.target, 0,\n\t\t\t\ttexture.format,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\t0,\n\t\t\t\ttexture.format,\n\t\t\t\ttexture.type,\n\t\t\t\tnull);\n\t\t}\n\n\t\tconst doClear = this.DO_CLEAR;\n\n\t\tif (doClear && !this._clearBuffer)\n\t\t{\n\t\t\tthis._clearBuffer = new Uint8Array(Constant.boundSize * Constant.boundSize * 4);\n\t\t}\n\n\t\tconst bounds = this.boundSprites;\n\n\t\tfor (let i = 0; i < bounds.length; i++)\n\t\t{\n\t\t\tconst spr = bounds[i];\n\t\t\tconst tex = spr.texture.baseTexture;\n\n\t\t\tif (glTexture.dirtyId >= this.dirties[i])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst res = tex.resource as any;\n\n\t\t\tif (!tex.valid || !res || !res.source)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (doClear && (tex.width < this.boundSize || tex.height < this.boundSize))\n\t\t\t{\n\t\t\t\tgl.texSubImage2D(texture.target, 0,\n\t\t\t\t\tspr.position.x,\n\t\t\t\t\tspr.position.y,\n\t\t\t\t\tthis.boundSize,\n\t\t\t\t\tthis.boundSize,\n\t\t\t\t\ttexture.format,\n\t\t\t\t\ttexture.type,\n\t\t\t\t\tthis._clearBuffer);\n\t\t\t}\n\t\t\tgl.texSubImage2D(texture.target, 0,\n\t\t\t\tspr.position.x,\n\t\t\t\tspr.position.y,\n\t\t\t\ttexture.format,\n\t\t\t\ttexture.type,\n\t\t\t\tres.source);\n\t\t}\n\n\t\treturn true;\n\t}\n}\n","import { Constant } from './const';\n\nimport type { TilemapShader } from './TilemapShader';\n\n/**\n * @internal\n * @ignore\n * @param shader\n * @param maxTextures\n */\nexport function fillSamplers(shader: TilemapShader, maxTextures: number): void\n{\n    const sampleValues: Array<number> = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    shader.uniforms.uSamplers = sampleValues;\n\n    const samplerSize: Array<number> = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        samplerSize.push(1.0 / Constant.bufferSize);\n        samplerSize.push(1.0 / Constant.bufferSize);\n    }\n\n    shader.uniforms.uSamplerSize = samplerSize;\n}\n\n/**\n * @internal\n * @ignore\n * @param maxTextures\n * @returns\n */\nexport function generateSampleSrc(maxTextures: number): string\n{\n    let src = '';\n\n    src += '\\n';\n    src += '\\n';\n\n    src += 'if(vTextureId <= -1.0) {';\n    src += '\\n\\tcolor = shadowColor;';\n    src += '\\n}';\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        src += '\\nelse ';\n\n        if (i < maxTextures - 1)\n        {\n            src += `if(textureId == ${i}.0)`;\n        }\n\n        src += '\\n{';\n        src += `\\n\\tcolor = texture2D(uSamplers[${i}], textureCoord * uSamplerSize[${i}]);`;\n        src += '\\n}';\n    }\n\n    src += '\\n';\n    src += '\\n';\n\n    return src;\n}\n\n/**\n * @internal\n * @ignore\n * @param maxTextures\n * @param fragmentSrc\n * @returns\n */\nexport function generateFragmentSrc(maxTextures: number, fragmentSrc: string): string\n{\n    return fragmentSrc.replace(/%count%/gi, `${maxTextures}`)\n        .replace(/%forloop%/gi, generateSampleSrc(maxTextures));\n}\n","// eslint-disable-next-line @typescript-eslint/triple-slash-reference, spaced-comment\n///<reference path=\"../global.d.ts\" />\n\nimport * as shaderGenerator from './shaderGenerator';\nimport tilemapShaderVertexSrc from './tilemap.vert';\nimport tilemapShaderFragmentSrc from './tilemap.frag';\n\nimport { Buffer, Geometry, Shader, Program } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\n\n// For some reason ESLint goes mad with indendation in this file ^&^\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\n\nexport abstract class TilemapShader extends Shader\n{\n\tmaxTextures = 0;\n\n\tconstructor(maxTextures: number, shaderVert: string, shaderFrag: string)\n\t{\n\t    super(\n\t        new Program(shaderVert, shaderFrag),\n\t        {\n\t            animationFrame: new Float32Array(2),\n\t            uSamplers: [],\n\t            uSamplerSize: [],\n\t            projTransMatrix: new Matrix()\n\t        }\n\t    );\n\n\t    this.maxTextures = maxTextures;\n\t    shaderGenerator.fillSamplers(this, this.maxTextures);\n\t}\n}\n\nexport class RectTileShader extends TilemapShader\n{\n    constructor(maxTextures: number)\n    {\n        super(\n            maxTextures,\n            tilemapShaderVertexSrc,\n            shaderGenerator.generateFragmentSrc(maxTextures, tilemapShaderFragmentSrc)\n        );\n        shaderGenerator.fillSamplers(this, this.maxTextures);\n    }\n}\n\nexport class RectTileGeom extends Geometry\n{\n\tvertSize = 11;\n\tvertPerQuad = 4;\n\tstride = this.vertSize * 4;\n\tlastTimeAccess = 0;\n\n\tconstructor()\n\t{\n\t    super();\n\n\t    const buf = this.buf = new Buffer(new Float32Array(2), true, false);\n\n\t    this.addAttribute('aVertexPosition', buf, 0, false, 0, this.stride, 0)\n\t        .addAttribute('aTextureCoord', buf, 0, false, 0, this.stride, 2 * 4)\n\t        .addAttribute('aFrame', buf, 0, false, 0, this.stride, 4 * 4)\n\t        .addAttribute('aAnim', buf, 0, false, 0, this.stride, 8 * 4)\n\t        .addAttribute('aTextureId', buf, 0, false, 0, this.stride, 10 * 4);\n\t}\n\n\tbuf: Buffer;\n}\n","import { WRAP_MODES } from '@pixi/constants';\nimport { BaseTexture, Buffer, ObjectRenderer, Texture, Renderer } from '@pixi/core';\nimport { Constant } from './const';\nimport { RectTileGeom, RectTileShader } from './TilemapShader';\nimport { MultiTextureResource } from './MultiTextureResource';\nimport * as utils from '@pixi/utils';\n\nimport type { TilemapShader } from './TilemapShader';\n\n// For some reason ESLint goes mad with indendation in this file ^&^\n/* eslint-disable no-mixed-spaces-and-tabs, indent */\n\n/** Rendering helper pipeline for tilemaps. */\nexport class TileRenderer extends ObjectRenderer\n{\n\t/** The managing renderer */\n\tpublic readonly renderer: Renderer;\n\n\t/** The tile animation frame */\n\tpublic tileAnim = [0, 0];\n\n\tprivate ibLen = 0;// index buffer length\n\tprivate indexBuffer: Buffer = null;\n\tprivate shader: RectTileShader;\n\tprivate texResources: Array<MultiTextureResource> = [];\n\n\t/** @param renderer - The managing renderer */\n\tconstructor(renderer: Renderer)\n\t{\n\t    super(renderer);\n\t    this.shader = new RectTileShader(Constant.maxTextures);\n\t    this.indexBuffer = new Buffer(undefined, true, true);\n\t    this.checkIndexBuffer(2000);\n\t    this.initBounds();\n\t}\n\n\t/**\n\t * This internal method is used to bind tile textures.\n\t *\n\t * This method has some undocumented performance characteristics.\n\t */\n\tbindTextures(renderer: Renderer, shader: TilemapShader, textures: Array<Texture>): void\n\t{\n\t    const len = textures.length;\n\t    const maxTextures = Constant.maxTextures;\n\n\t    if (len > Constant.boundCountPerBuffer * maxTextures)\n\t    {\n\t        return;\n\t    }\n\t    if (Constant.boundCountPerBuffer <= 1)\n\t    {\n\t        this.bindTexturesWithoutRT(renderer, shader, textures);\n\n\t        return;\n\t    }\n\n\t    let i = 0;\n\n\t    for (; i < len; i++)\n\t    {\n\t        const texture = textures[i];\n\n\t        if (!texture || !texture.valid) continue;\n\t        const multi = this.texResources[i >> 2];\n\n\t        multi.setTexture(i & 3, texture);\n\t    }\n\n\t    const gltsUsed = (i + 3) >> 2;\n\n\t    for (i = 0; i < gltsUsed; i++)\n\t    {\n\t        // remove \"i, true\" after resolving a bug\n\t        renderer.texture.bind(this.texResources[i].baseTex, i);\n\t    }\n\t}\n\n\tstart(): void\n\t{\n\t    // sorry, nothing\n\t}\n\n\t/**\n\t * @internal\n\t * @ignore\n\t */\n\tcreateVb(): RectTileGeom\n\t{\n\t    const geom = new RectTileGeom();\n\n\t    geom.addIndex(this.indexBuffer);\n\t    geom.lastTimeAccess = Date.now();\n\n\t    return geom;\n\t}\n\n\t/** @return The {@link TilemapShader} shader that this rendering pipeline is using. */\n\tgetShader(): TilemapShader { return this.shader; }\n\n\tdestroy(): void\n\t{\n\t    super.destroy();\n\t    // this.rectShader.destroy();\n\t    this.shader = null;\n\t}\n\n\tpublic checkIndexBuffer(size: number, _vb: RectTileGeom = null): void\n\t{\n\t    const totalIndices = size * 6;\n\n\t    if (totalIndices <= this.ibLen)\n\t    {\n\t        return;\n\t    }\n\n\t    let len = totalIndices;\n\n\t    while (len < totalIndices)\n\t    {\n\t        len <<= 1;\n\t    }\n\n\t    this.ibLen = totalIndices;\n\t    this.indexBuffer.update(utils.createIndicesForQuads(size,\n\t        Constant.use32bitIndex ? new Uint32Array(size * 6) : undefined));\n\n\t    // \tTODO: create new index buffer instead?\n\t    // if (vb) {\n\t    // \tconst curIndex = vb.getIndex();\n\t    // \tif (curIndex !== this.indexBuffer && (curIndex.data as any).length < totalIndices) {\n\t    // \t\tthis.swapIndex(vb, this.indexBuffer);\n\t    // \t}\n\t    // }\n\t}\n\n\tprivate initBounds(): void\n\t{\n\t    if (Constant.boundCountPerBuffer <= 1)\n\t    {\n\t        return;\n\t    }\n\n\t    const maxTextures = Constant.maxTextures;\n\n\t    for (let i = 0; i < maxTextures; i++)\n\t    {\n\t        const resource = new MultiTextureResource(Constant);\n\t        const baseTex = new BaseTexture(resource);\n\n\t        baseTex.scaleMode = Constant.SCALE_MODE;\n\t        baseTex.wrapMode = WRAP_MODES.CLAMP;\n\t        this.texResources.push(resource);\n\t    }\n\t}\n\n\tprivate bindTexturesWithoutRT(renderer: Renderer, shader: TilemapShader, textures: Array<Texture>): void\n\t{\n\t    const samplerSize: Array<number> = (shader as any).uniforms.uSamplerSize;\n\n\t\tfor (let i = 0; i < textures.length; i++)\n\t    {\n\t        const texture = textures[i];\n\n\t        if (!texture || !texture.valid)\n\t        {\n\t            return;\n\t        }\n\n\t\t\trenderer.texture.bind(textures[i], i);\n\t        // TODO: add resolution here\n\t        samplerSize[i * 2] = 1.0 / textures[i].baseTexture.width;\n\t        samplerSize[(i * 2) + 1] = 1.0 / textures[i].baseTexture.height;\n\t    }\n\t    (shader as any).uniforms.uSamplerSize = samplerSize;\n\t}\n}\n\nRenderer.registerPlugin('tilemap', TileRenderer as any);\n","import { CanvasTileRenderer } from './CanvasTileRenderer';\nimport { CompositeTilemap } from './CompositeTilemap';\nimport { Constant } from './const';\nimport { MultiTextureResource } from './MultiTextureResource';\nimport { Tilemap } from './Tilemap';\nimport { TilemapShader, RectTileShader, RectTileGeom } from './TilemapShader';\nimport { TileRenderer } from './TileRenderer';\n\n// Prevent SCALE_MODES from becoming lazy import in Constant.ts - which causes a import() in the declaration file,\n// which causes API extractor to fail https://github.com/microsoft/rushstack/issues/2140\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport * as constants from '@pixi/constants';\n\n// eslint-disable-next-line camelcase\nexport const pixi_tilemap = {\n    CanvasTileRenderer,\n    CompositeRectTileLayer: CompositeTilemap,\n    CompositeTilemap,\n    Constant,\n    MultiTextureResource,\n    RectTileLayer: Tilemap,\n    Tilemap,\n    TilemapShader,\n    RectTileShader,\n    RectTileGeom,\n    TileRenderer,\n};\n\nexport * from './CanvasTileRenderer';\nexport * from './CompositeTilemap';\nexport * from './const';\nexport * from './MultiTextureResource';\nexport * from './Tilemap';\nexport * from './TilemapShader';\nexport * from './shaderGenerator';\nexport * from './TileRenderer';\n\nexport { CompositeTilemap as CompositeRectTileLayer } from './CompositeTilemap';\nexport { Tilemap as RectTileLayer } from './Tilemap';\n"],"names":["Renderer"],"mappings":";;;;;;;;;;;;;;;;;;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IC7BA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;ACEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IC5pBA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;ICpgBA;IACA;AACA;IACA;IACA;IACA;IACA;;IAEA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;;IC3IA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;;;;;;IChFA;AASA;IACA;IACA;AACA;;IAEA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;;IAEA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;;IC3DA;IACA;AACA;IACA;;IAEA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;AACAA;;ICrKA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}